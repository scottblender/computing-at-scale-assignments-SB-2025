## How did you test your code? What are the limitations of your testing?
To test my code, I used matrix3.mtx times matrix4.mtx as input matrices and matrix3.mtx times vector2.mtx as the input matrix and vector to check the matrix-matrix product and matrix-vector product. This verification was done by hand as I do not have experience with testing in C++. This method of verification is limited since I was only able to check one example. Proper testing should be more thorough and check all possible cases one can encounter for a variety of verifiable matrix multiplications. I also checked error messages to make sure the errors I programmed were correct and occurred at the appropriate time. For instance, when operation type 1 was selected, I sent in a matrix and a vector and my code exited since it expects two matrices.
## What are the limitations of the matrix market format for dense matrices?
The limitations of the matrix market format for dense matrices mostly tie into storage inefficiency. This format works well for sparse matrices, which have many zero entries. For dense matrices, though, this is not great because matrix market format stores each unique value explicitly. Thus, fordense matrices, more memory allocation is required for matrix market format, even if less memory can be used.
## If you know the size of the matrices at compile time, how would you change your code to take advantage of this information?
Having fixed-size matrices allows you to reduce the amount of memory needed to be available at runtime (heap memory). This allows you to create references/pointers and perform inline operations, which can be implemented in the code. For instance the loops over each column and row can be unrolled to speed up performance.
## Was your matrix representation row-major or column-major? How did you decide? Do you think this will have an impact on performance?
I used row-major storage because this is what I am most familiar with and most libraries use this method of storage. I don't believe there would be a difference in performance since each item needs to be stored individually in memory regardless.
## What approach did you take to document your functions and driver program?
I wrote function headers which included what input arguments and output arguments the function requested and outputted and commented important linesin them and the driver program. Wherever data types or structures were being created, modified, or deleted and wherver loops or functions were being called, I added comments in the driver program as well to explain functionality and objectives of what the code should do.
## Is your code robust to errors in the input files? How did you test this?
My code is robust to errors in the input files. I manually tested this based on recommendations from the matrix market website. Key errors in the input files my code is robust to include whether the banner can be processed, whether the size is appropriate, and whether the file can be opened. There are more errors that may be important to check such as the numbers stored in the matrix market file; however these were not implemented.
## Are there any limitations in your implementation you are aware of? Do you have any ideas on how to address them? e.g., what is the maximum size of the matrices you can handle?
The maximum size of the matrices that can be handled depends on system memory. It can be directly found by using std::cout << std::vector<double> vec.max_size() << endl. In theory, for a 64 bit system, this should be on the order of magnitude of 2^63 for every 1 element, but this also depends on the amount of memory available. Additionally limitations include numerical precision, i.e. machine error in performing calculations must be taken into consideration. Other limitations include using matrix market format to import a dense matrix. The latter is resolvable by using a different format; however, the first two are limitations of the computer and must be considered when performing calculations depending on the resolution needed.
## If you wanted to optimize the performance of your code, what approach would you take?
To optimize the performance, I would focus on the data structures used and how I can simplify loops/repeated calculations. I would also investigate alternatives to storing data from each matrix imported, for instance, if there are repeated values, using a different format than the matrix market to take advantage of this.
